<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Iaret — Living Avatar</title>
<style>
  :root {
    --aura-color: rgba(147, 51, 234, 0.35);
    --aura-color-strong: rgba(147, 51, 234, 0.6);
    --gold: #d4a843;
    --gold-glow: rgba(212, 168, 67, 0.5);
    --violet: #9333ea;
    --violet-deep: #581c87;
    --cosmic-bg: #0a0612;
    --energy: 0.5;
    --positivity: 0.5;
    --breath-duration: 4.5s;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: var(--cosmic-bg);
    overflow: hidden;
    width: 100vw;
    height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
    font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
    cursor: default;
    user-select: none;
  }

  /* ── Cosmic background ── */
  #cosmos {
    position: fixed;
    inset: 0;
    z-index: 0;
  }

  /* ══════════════════════════════════════
     PORTRAIT MODE (circular bust frame)
     ══════════════════════════════════════ */

  #avatar-stage {
    position: relative;
    width: min(85vh, 85vw);
    height: min(85vh, 85vw);
    z-index: 1;
    transition: all 0.8s cubic-bezier(0.4, 0, 0.2, 1);
  }

  /* Full-body mode overrides */
  body.fullbody #avatar-stage {
    width: min(45vw, 60vh);
    height: min(90vh, 120vw);
  }

  /* ── Aura rings ── */
  .aura {
    position: absolute;
    inset: -8%;
    border-radius: 50%;
    pointer-events: none;
    transition: all 0.8s ease;
  }
  .aura-outer {
    background: radial-gradient(ellipse at center,
      transparent 50%,
      var(--aura-color) 70%,
      transparent 85%);
    animation: aura-pulse var(--breath-duration) ease-in-out infinite;
  }
  .aura-inner {
    inset: 2%;
    background: radial-gradient(ellipse at center,
      transparent 55%,
      var(--aura-color-strong) 72%,
      transparent 80%);
    animation: aura-pulse var(--breath-duration) ease-in-out infinite;
    animation-delay: calc(var(--breath-duration) * -0.5);
  }

  /* Full-body: elongated vertical aura */
  body.fullbody .aura {
    border-radius: 40% / 50%;
    inset: -6% -15%;
  }

  @keyframes aura-pulse {
    0%, 100% { transform: scale(1); opacity: 0.6; }
    50% { transform: scale(1.05); opacity: 1; }
  }

  /* ── Portrait frame ── */
  #portrait-frame {
    position: absolute;
    inset: 5%;
    border-radius: 50%;
    overflow: hidden;
    animation: breathe var(--breath-duration) ease-in-out infinite;
    box-shadow:
      0 0 40px var(--aura-color),
      0 0 80px rgba(147, 51, 234, 0.15),
      inset 0 0 30px rgba(0, 0, 0, 0.4);
    transition: border-radius 0.8s cubic-bezier(0.4, 0, 0.2, 1);
  }

  /* Full-body: tall rounded rectangle */
  body.fullbody #portrait-frame {
    border-radius: 20px;
    inset: 3%;
  }

  @keyframes breathe {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.012); }
  }

  /* ── Avatar images (layered for crossfade) ── */
  .avatar-layer {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
    object-position: center top;
    opacity: 0;
    transition: opacity 1.2s cubic-bezier(0.4, 0, 0.2, 1);
    will-change: opacity;
  }
  .avatar-layer.active {
    opacity: 1;
  }

  /* Full-body layers */
  .avatar-layer.fullbody-layer {
    object-fit: contain;
    object-position: center center;
  }

  /* ── Eye shimmer overlay ── */
  #eye-shimmer {
    position: absolute;
    inset: 0;
    background: radial-gradient(
      ellipse 30% 8% at 42% 35%,
      rgba(255, 255, 255, 0.12) 0%,
      transparent 100%),
    radial-gradient(
      ellipse 30% 8% at 58% 35%,
      rgba(255, 255, 255, 0.12) 0%,
      transparent 100%);
    opacity: 0;
    animation: eye-glint 6s ease-in-out infinite;
    pointer-events: none;
    transition: background 0.8s ease;
  }

  /* Full-body: reposition eye shimmer higher */
  body.fullbody #eye-shimmer {
    background: radial-gradient(
      ellipse 20% 4% at 45% 18%,
      rgba(255, 255, 255, 0.10) 0%,
      transparent 100%),
    radial-gradient(
      ellipse 20% 4% at 55% 18%,
      rgba(255, 255, 255, 0.10) 0%,
      transparent 100%);
  }

  @keyframes eye-glint {
    0%, 85%, 100% { opacity: 0; }
    90% { opacity: 1; }
    95% { opacity: 0; }
  }

  /* ── Blink overlay ── */
  #blink-overlay {
    position: absolute;
    inset: 0;
    background: linear-gradient(
      to bottom,
      transparent 28%,
      rgba(10, 6, 18, 0.7) 33%,
      rgba(10, 6, 18, 0.7) 37%,
      transparent 42%);
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.08s ease;
  }

  body.fullbody #blink-overlay {
    background: linear-gradient(
      to bottom,
      transparent 14%,
      rgba(10, 6, 18, 0.7) 17%,
      rgba(10, 6, 18, 0.7) 20%,
      transparent 23%);
  }

  /* ── Speaking indicator (subtle mouth glow) ── */
  #speak-glow {
    position: absolute;
    inset: 0;
    background: radial-gradient(
      ellipse 25% 12% at 50% 68%,
      var(--gold-glow) 0%,
      transparent 100%);
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s ease;
  }
  body.fullbody #speak-glow {
    background: radial-gradient(
      ellipse 18% 5% at 50% 28%,
      var(--gold-glow) 0%,
      transparent 100%);
  }
  #speak-glow.active {
    animation: speak-pulse 0.6s ease-in-out infinite alternate;
  }

  @keyframes speak-pulse {
    0% { opacity: 0.15; }
    100% { opacity: 0.45; }
  }

  /* ── Gold ring border ── */
  #gold-ring {
    position: absolute;
    inset: 4.5%;
    border-radius: 50%;
    border: 2px solid var(--gold);
    opacity: 0.4;
    pointer-events: none;
    box-shadow: 0 0 15px var(--gold-glow), inset 0 0 15px var(--gold-glow);
    animation: ring-breathe var(--breath-duration) ease-in-out infinite;
    transition: border-radius 0.8s cubic-bezier(0.4, 0, 0.2, 1), inset 0.8s ease;
  }

  body.fullbody #gold-ring {
    border-radius: 18px;
    inset: 2.5%;
  }

  @keyframes ring-breathe {
    0%, 100% { opacity: 0.3; }
    50% { opacity: 0.6; }
  }

  /* ══════════════════════════════════════
     FULL-BODY TURNAROUND: ground glow
     ══════════════════════════════════════ */

  #ground-glow {
    display: none;
    position: absolute;
    bottom: -5%;
    left: -10%;
    right: -10%;
    height: 25%;
    background: radial-gradient(
      ellipse 60% 100% at 50% 100%,
      var(--aura-color-strong) 0%,
      var(--aura-color) 40%,
      transparent 80%);
    pointer-events: none;
    animation: ground-pulse var(--breath-duration) ease-in-out infinite;
    filter: blur(8px);
  }
  body.fullbody #ground-glow { display: block; }

  @keyframes ground-pulse {
    0%, 100% { opacity: 0.4; transform: scaleX(1); }
    50% { opacity: 0.7; transform: scaleX(1.05); }
  }

  /* ══════════════════════════════════════
     TURNAROUND ANGLE INDICATOR
     ══════════════════════════════════════ */

  #angle-indicator {
    display: none;
    position: fixed;
    bottom: 80px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 10;
    pointer-events: none;
  }
  body.fullbody #angle-indicator { display: flex; }

  .angle-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    margin: 0 6px;
    background: rgba(147, 51, 234, 0.25);
    border: 1px solid rgba(147, 51, 234, 0.3);
    transition: all 0.4s ease;
  }
  .angle-dot.active {
    background: var(--gold);
    border-color: var(--gold);
    box-shadow: 0 0 8px var(--gold-glow);
    transform: scale(1.3);
  }

  .angle-label {
    position: absolute;
    top: -20px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 0.6rem;
    letter-spacing: 0.15em;
    color: rgba(192, 160, 255, 0.5);
    white-space: nowrap;
    opacity: 0;
    transition: opacity 0.4s ease;
  }
  body.fullbody .angle-label { opacity: 1; }

  /* ── Mode toggle button ── */
  #mode-toggle {
    position: fixed;
    top: 16px;
    left: 16px;
    z-index: 10;
    background: rgba(147, 51, 234, 0.15);
    border: 1px solid rgba(147, 51, 234, 0.3);
    border-radius: 6px;
    color: rgba(192, 160, 255, 0.7);
    font-size: 0.7rem;
    letter-spacing: 0.1em;
    padding: 6px 12px;
    cursor: pointer;
    transition: all 0.3s ease;
    font-family: inherit;
    text-transform: uppercase;
  }
  #mode-toggle:hover {
    background: rgba(147, 51, 234, 0.3);
    color: var(--gold);
    border-color: var(--gold);
  }

  /* ── Status HUD ── */
  #hud {
    position: fixed;
    bottom: 24px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 10;
    text-align: center;
    pointer-events: none;
  }

  #persona-name {
    font-size: 1.3rem;
    font-weight: 300;
    letter-spacing: 0.3em;
    text-transform: uppercase;
    color: var(--gold);
    text-shadow: 0 0 20px var(--gold-glow);
    margin-bottom: 6px;
  }

  #status-text {
    font-size: 0.8rem;
    letter-spacing: 0.15em;
    color: rgba(192, 160, 255, 0.7);
    transition: all 0.6s ease;
  }

  #mood-bar {
    margin-top: 8px;
    height: 2px;
    width: 200px;
    background: rgba(147, 51, 234, 0.2);
    border-radius: 1px;
    overflow: hidden;
    margin-left: auto;
    margin-right: auto;
  }

  #mood-fill {
    height: 100%;
    width: 50%;
    background: linear-gradient(90deg, var(--violet), var(--gold));
    border-radius: 1px;
    transition: width 1.5s ease, background 1.5s ease;
  }

  /* ── Connection indicator ── */
  #connection {
    position: fixed;
    top: 16px;
    right: 16px;
    z-index: 10;
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 0.7rem;
    color: rgba(192, 160, 255, 0.5);
    letter-spacing: 0.1em;
  }

  #conn-dot {
    width: 6px;
    height: 6px;
    border-radius: 50%;
    background: #555;
    transition: background 0.5s ease;
  }
  #conn-dot.connected { background: #4ade80; box-shadow: 0 0 8px rgba(74, 222, 128, 0.5); }
  #conn-dot.reconnecting { background: #facc15; animation: blink-dot 1s infinite; }

  @keyframes blink-dot {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.3; }
  }

  /* ── Floating particles (ankh / star motifs) ── */
  .particle {
    position: fixed;
    color: var(--gold);
    opacity: 0;
    pointer-events: none;
    font-size: 14px;
    animation: float-up linear infinite;
    will-change: transform, opacity;
  }

  @keyframes float-up {
    0%   { transform: translateY(0) rotate(0deg) scale(0.5); opacity: 0; }
    15%  { opacity: 0.6; }
    85%  { opacity: 0.3; }
    100% { transform: translateY(-100vh) rotate(360deg) scale(0.2); opacity: 0; }
  }
</style>
</head>
<body>

<canvas id="cosmos"></canvas>

<div id="avatar-stage">
  <div class="aura aura-outer"></div>
  <div class="aura aura-inner"></div>

  <div id="portrait-frame">
    <!-- Portrait mode layers (bust) — crossfaded by state -->
    <img class="avatar-layer portrait-layer active" id="layer-idle"        src="idle.png"        alt="" draggable="false">
    <img class="avatar-layer portrait-layer"        id="layer-listening"   src="listening.png"   alt="" draggable="false">
    <img class="avatar-layer portrait-layer"        id="layer-thinking"    src="thinking.png"    alt="" draggable="false">
    <img class="avatar-layer portrait-layer"        id="layer-speaking"    src="speaking.png"    alt="" draggable="false">
    <img class="avatar-layer portrait-layer"        id="layer-encouraging" src="encouraging.png" alt="" draggable="false">

    <!-- Full-body mode layers (turnaround angles) — crossfaded by angle -->
    <img class="avatar-layer fullbody-layer" id="layer-fb-front"      src="fullbody_front.png"      alt="" draggable="false">
    <img class="avatar-layer fullbody-layer" id="layer-fb-threequarter" src="fullbody_threequarter.png" alt="" draggable="false">
    <img class="avatar-layer fullbody-layer" id="layer-fb-side"       src="fullbody_side.png"       alt="" draggable="false">
    <img class="avatar-layer fullbody-layer" id="layer-fb-back"       src="fullbody_back.png"       alt="" draggable="false">
    <img class="avatar-layer fullbody-layer" id="layer-fb-sideleft"   src="fullbody_sideleft.png"   alt="" draggable="false">

    <div id="eye-shimmer"></div>
    <div id="blink-overlay"></div>
    <div id="speak-glow"></div>
  </div>

  <div id="gold-ring"></div>
  <div id="ground-glow"></div>
</div>

<!-- Turnaround angle indicator dots -->
<div id="angle-indicator">
  <span class="angle-label" id="angle-name">front</span>
  <div class="angle-dot active" data-angle="0"></div>
  <div class="angle-dot" data-angle="1"></div>
  <div class="angle-dot" data-angle="2"></div>
  <div class="angle-dot" data-angle="3"></div>
  <div class="angle-dot" data-angle="4"></div>
</div>

<button id="mode-toggle">Portrait</button>

<div id="hud">
  <div id="persona-name">Iaret</div>
  <div id="status-text">Awakening...</div>
  <div id="mood-bar"><div id="mood-fill"></div></div>
</div>

<div id="connection">
  <span id="conn-dot"></span>
  <span id="conn-label">DISCONNECTED</span>
</div>

<div id="particles"></div>

<script>
// ═══════════════════════════════════════════════
//  Cosmic background — star field on canvas
// ═══════════════════════════════════════════════
const cosmos = document.getElementById('cosmos');
const ctx = cosmos.getContext('2d');
let stars = [];

function resizeCosmos() {
  cosmos.width = window.innerWidth;
  cosmos.height = window.innerHeight;
  initStars();
}

function initStars() {
  stars = [];
  const count = Math.floor((cosmos.width * cosmos.height) / 3000);
  for (let i = 0; i < count; i++) {
    stars.push({
      x: Math.random() * cosmos.width,
      y: Math.random() * cosmos.height,
      r: Math.random() * 1.5 + 0.3,
      a: Math.random(),
      speed: Math.random() * 0.0008 + 0.0002,
      phase: Math.random() * Math.PI * 2,
    });
  }
}

function drawCosmos(t) {
  ctx.clearRect(0, 0, cosmos.width, cosmos.height);

  // Nebula gradient
  const grd = ctx.createRadialGradient(
    cosmos.width * 0.5, cosmos.height * 0.45, 0,
    cosmos.width * 0.5, cosmos.height * 0.45, cosmos.width * 0.7
  );
  grd.addColorStop(0, 'rgba(88, 28, 135, 0.08)');
  grd.addColorStop(0.5, 'rgba(59, 7, 100, 0.04)');
  grd.addColorStop(1, 'transparent');
  ctx.fillStyle = grd;
  ctx.fillRect(0, 0, cosmos.width, cosmos.height);

  // Stars
  for (const s of stars) {
    const twinkle = 0.4 + 0.6 * Math.sin(t * s.speed * 1000 + s.phase);
    ctx.beginPath();
    ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(210, 190, 255, ${s.a * twinkle})`;
    ctx.fill();
  }

  requestAnimationFrame(drawCosmos);
}

window.addEventListener('resize', resizeCosmos);
resizeCosmos();
requestAnimationFrame(drawCosmos);


// ═══════════════════════════════════════════════
//  Floating particles — ankh motifs
// ═══════════════════════════════════════════════
const particlesEl = document.getElementById('particles');
const SYMBOLS = ['☥', '✦', '◆', '✧', '⟐', '◇'];

function spawnParticle() {
  const el = document.createElement('div');
  el.className = 'particle';
  el.textContent = SYMBOLS[Math.floor(Math.random() * SYMBOLS.length)];
  el.style.left = (Math.random() * 100) + 'vw';
  el.style.fontSize = (10 + Math.random() * 12) + 'px';
  el.style.animationDuration = (8 + Math.random() * 12) + 's';
  el.style.animationDelay = '0s';
  el.style.color = Math.random() > 0.5
    ? 'rgba(212, 168, 67, 0.4)'
    : 'rgba(192, 160, 255, 0.3)';
  particlesEl.appendChild(el);
  setTimeout(() => el.remove(), 20000);
}

setInterval(spawnParticle, 1200);
for (let i = 0; i < 8; i++) setTimeout(spawnParticle, i * 300);


// ═══════════════════════════════════════════════
//  Blink simulation
// ═══════════════════════════════════════════════
const blinkEl = document.getElementById('blink-overlay');

function scheduleBlink() {
  const delay = 3000 + Math.random() * 5000;
  setTimeout(() => {
    // Only blink when showing front-facing images
    if (isFullbody && currentAngle > 1) { scheduleBlink(); return; }

    blinkEl.style.opacity = '1';
    setTimeout(() => { blinkEl.style.opacity = '0'; }, 120);
    if (Math.random() < 0.2) {
      setTimeout(() => {
        blinkEl.style.opacity = '1';
        setTimeout(() => { blinkEl.style.opacity = '0'; }, 100);
      }, 250);
    }
    scheduleBlink();
  }, delay);
}
scheduleBlink();


// ═══════════════════════════════════════════════
//  View mode management (portrait vs fullbody)
// ═══════════════════════════════════════════════
let isFullbody = false;
const modeToggle = document.getElementById('mode-toggle');
const portraitLayers = document.querySelectorAll('.portrait-layer');
const fullbodyLayers = document.querySelectorAll('.fullbody-layer');
const angleName = document.getElementById('angle-name');

const ANGLES = ['front', '¾ right', 'profile right', 'back', 'profile left'];

function setViewMode(fullbody) {
  isFullbody = fullbody;
  document.body.classList.toggle('fullbody', fullbody);
  modeToggle.textContent = fullbody ? 'Full Body' : 'Portrait';

  // Show/hide appropriate layer sets
  portraitLayers.forEach(el => {
    el.style.display = fullbody ? 'none' : '';
  });
  fullbodyLayers.forEach(el => {
    el.style.display = fullbody ? '' : 'none';
  });

  if (fullbody) {
    // Hide portrait overlays that don't map well to back views
    setAngle(currentAngle);
  } else {
    // Restore portrait state
    setAvatarState(currentState);
  }
}

// Initialize: hide fullbody layers
fullbodyLayers.forEach(el => { el.style.display = 'none'; });

modeToggle.addEventListener('click', () => setViewMode(!isFullbody));


// ═══════════════════════════════════════════════
//  Turnaround angle management (fullbody mode)
// ═══════════════════════════════════════════════
let currentAngle = 0;
const fbLayers = {
  0: document.getElementById('layer-fb-front'),
  1: document.getElementById('layer-fb-threequarter'),
  2: document.getElementById('layer-fb-side'),
  3: document.getElementById('layer-fb-back'),
  4: document.getElementById('layer-fb-sideleft'),
};
const angleDots = document.querySelectorAll('.angle-dot');

function setAngle(angle) {
  if (angle < 0 || angle > 4) angle = 0;
  currentAngle = angle;

  // Crossfade fullbody layers
  for (const [key, el] of Object.entries(fbLayers)) {
    el.classList.toggle('active', parseInt(key) === angle);
  }

  // Update indicator dots
  angleDots.forEach((dot, i) => dot.classList.toggle('active', i === angle));
  angleName.textContent = ANGLES[angle] || 'front';

  // Disable face effects on back/side views
  const showFace = angle <= 1;
  document.getElementById('eye-shimmer').style.display = showFace ? '' : 'none';
  blinkEl.style.display = showFace ? '' : 'none';
  document.getElementById('speak-glow').style.display = showFace ? '' : 'none';
}

// Auto-turnaround: slowly rotate through angles when idle in fullbody mode
let turnaroundTimer = null;
let turnaroundPaused = false;

function startTurnaround() {
  stopTurnaround();
  turnaroundTimer = setInterval(() => {
    if (turnaroundPaused || !isFullbody) return;
    setAngle((currentAngle + 1) % 5);
  }, 4000);
}

function stopTurnaround() {
  if (turnaroundTimer) { clearInterval(turnaroundTimer); turnaroundTimer = null; }
}

// Start turnaround on idle, pause when active
function updateTurnaroundForState(state) {
  if (!isFullbody) return;
  if (state === 'Idle') {
    turnaroundPaused = false;
    if (!turnaroundTimer) startTurnaround();
  } else {
    // When speaking/listening/thinking, face front
    turnaroundPaused = true;
    setAngle(state === 'Listening' ? 1 : 0);
  }
}


// ═══════════════════════════════════════════════
//  Avatar state management (portrait mode)
// ═══════════════════════════════════════════════
const layers = {
  Idle:        document.getElementById('layer-idle'),
  Listening:   document.getElementById('layer-listening'),
  Thinking:    document.getElementById('layer-thinking'),
  Speaking:    document.getElementById('layer-speaking'),
  Encouraging: document.getElementById('layer-encouraging'),
};

const speakGlow = document.getElementById('speak-glow');
const statusText = document.getElementById('status-text');
const personaNameEl = document.getElementById('persona-name');
const moodFill = document.getElementById('mood-fill');
const connDot = document.getElementById('conn-dot');
const connLabel = document.getElementById('conn-label');

let currentState = 'Idle';

const STATE_STATUS = {
  Idle:        'Watchful stillness',
  Listening:   'Listening...',
  Thinking:    'Contemplating...',
  Speaking:    'Speaking',
  Encouraging: 'With warmth',
};

function setAvatarState(state) {
  if (!layers[state]) state = 'Idle';
  if (state === currentState && !isFullbody) return;

  if (!isFullbody) {
    // Crossfade portrait layers
    for (const [key, el] of Object.entries(layers)) {
      el.classList.toggle('active', key === state);
    }
  }

  // Speaking glow (works in both modes for front-facing)
  speakGlow.classList.toggle('active', state === 'Speaking');

  // Breathing speed varies by state
  const root = document.documentElement;
  switch (state) {
    case 'Listening': root.style.setProperty('--breath-duration', '3.5s'); break;
    case 'Thinking':  root.style.setProperty('--breath-duration', '5.5s'); break;
    case 'Speaking':  root.style.setProperty('--breath-duration', '2.8s'); break;
    default:          root.style.setProperty('--breath-duration', '4.5s'); break;
  }

  currentState = state;

  // In fullbody mode, state influences angle
  updateTurnaroundForState(state);
}

function applySnapshot(snap) {
  // snap: { VisualState, Mood, Energy, Positivity, StatusText, PersonaName }
  const stateNames = ['Idle', 'Listening', 'Thinking', 'Speaking', 'Encouraging'];
  const visualName = typeof snap.VisualState === 'number'
    ? (stateNames[snap.VisualState] || 'Idle')
    : snap.VisualState;

  setAvatarState(visualName);

  // Update HUD
  if (snap.PersonaName) personaNameEl.textContent = snap.PersonaName;
  statusText.textContent = snap.StatusText
    ? `${snap.Mood || ''} — ${snap.StatusText}`.replace(/^ — /, '')
    : (snap.Mood || STATE_STATUS[visualName] || '');

  // Mood bar = positivity
  const positivity = Math.max(0, Math.min(1, snap.Positivity || 0.5));
  moodFill.style.width = (positivity * 100) + '%';

  // Aura intensity from energy
  const energy = Math.max(0, Math.min(1, snap.Energy || 0.5));
  const auraAlpha = 0.2 + energy * 0.5;
  document.documentElement.style.setProperty(
    '--aura-color', `rgba(147, 51, 234, ${auraAlpha})`);
  document.documentElement.style.setProperty(
    '--aura-color-strong', `rgba(147, 51, 234, ${auraAlpha + 0.15})`);
}


// ═══════════════════════════════════════════════
//  WebSocket connection to CLI host
// ═══════════════════════════════════════════════
const WS_PORT = new URLSearchParams(window.location.search).get('port') || '9471';
let ws = null;
let reconnectDelay = 1000;

function connectWs() {
  connDot.className = 'reconnecting';
  connLabel.textContent = 'CONNECTING';

  ws = new WebSocket(`ws://localhost:${WS_PORT}/avatar`);

  ws.onopen = () => {
    reconnectDelay = 1000;
    connDot.className = 'connected';
    connLabel.textContent = 'LINKED';
    statusText.textContent = 'Connected to Ouroboros';
  };

  ws.onmessage = (ev) => {
    try {
      const snap = JSON.parse(ev.data);
      applySnapshot(snap);
    } catch (e) {
      console.warn('Invalid avatar state:', e);
    }
  };

  ws.onclose = () => {
    connDot.className = '';
    connLabel.textContent = 'DISCONNECTED';
    statusText.textContent = 'Awaiting reconnection...';
    setTimeout(connectWs, reconnectDelay);
    reconnectDelay = Math.min(reconnectDelay * 1.5, 8000);
  };

  ws.onerror = () => ws.close();
}

connectWs();


// ═══════════════════════════════════════════════
//  Idle ambient state cycling
// ═══════════════════════════════════════════════
let lastUpdateTime = Date.now();

setInterval(() => {
  if (Date.now() - lastUpdateTime > 30000 && currentState === 'Idle') {
    if (Math.random() < 0.3) {
      if (isFullbody) {
        // In fullbody idle, the turnaround handles ambient motion
      } else {
        setAvatarState('Encouraging');
        setTimeout(() => setAvatarState('Idle'), 2500);
      }
    }
  }
}, 15000);

const origApply = applySnapshot;
applySnapshot = function(snap) {
  lastUpdateTime = Date.now();
  origApply(snap);
};


// ═══════════════════════════════════════════════
//  Keyboard shortcuts
// ═══════════════════════════════════════════════
document.addEventListener('keydown', (e) => {
  switch(e.key) {
    // State shortcuts (portrait mode)
    case '1': setAvatarState('Idle'); break;
    case '2': setAvatarState('Listening'); break;
    case '3': setAvatarState('Thinking'); break;
    case '4': setAvatarState('Speaking'); break;
    case '5': setAvatarState('Encouraging'); break;

    // Angle shortcuts (fullbody mode)
    case 'q': if (isFullbody) { turnaroundPaused = true; setAngle(0); } break;
    case 'w': if (isFullbody) { turnaroundPaused = true; setAngle(1); } break;
    case 'e': if (isFullbody) { turnaroundPaused = true; setAngle(2); } break;
    case 'r': if (isFullbody) { turnaroundPaused = true; setAngle(3); } break;
    case 't': if (isFullbody) { turnaroundPaused = true; setAngle(4); } break;

    // Arrow keys rotate in fullbody
    case 'ArrowLeft':
      if (isFullbody) { turnaroundPaused = true; setAngle((currentAngle + 4) % 5); }
      break;
    case 'ArrowRight':
      if (isFullbody) { turnaroundPaused = true; setAngle((currentAngle + 1) % 5); }
      break;

    // Toggle view mode
    case 'f': setViewMode(!isFullbody); break;
    // Resume auto-turnaround
    case ' ': if (isFullbody) { turnaroundPaused = false; startTurnaround(); } break;
  }
});
</script>
</body>
</html>
