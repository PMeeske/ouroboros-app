<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Iaret — Living Avatar</title>
<style>
  :root {
    --aura-color: rgba(147, 51, 234, 0.35);
    --aura-color-strong: rgba(147, 51, 234, 0.6);
    --gold: #d4a843;
    --gold-glow: rgba(212, 168, 67, 0.5);
    --violet: #9333ea;
    --violet-deep: #581c87;
    --cosmic-bg: #0a0612;
    --holo-cyan: rgba(0, 255, 220, 0.7);
    --holo-violet: rgba(147, 51, 234, 0.5);
    --energy: 0.5;
    --positivity: 0.5;
    --breath-duration: 4.5s;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: var(--cosmic-bg);
    overflow: hidden;
    width: 100vw;
    height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
    font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
    cursor: default;
    user-select: none;
  }

  /* ── Cosmic background ── */
  #cosmos {
    position: fixed;
    inset: 0;
    z-index: 0;
  }

  /* ══════════════════════════════════════
     AVATAR STAGE
     ══════════════════════════════════════ */

  #avatar-stage {
    position: relative;
    width: min(85vh, 85vw);
    height: min(85vh, 85vw);
    z-index: 1;
    transition: all 0.8s cubic-bezier(0.4, 0, 0.2, 1);
  }

  body.fullbody #avatar-stage {
    width: min(45vw, 60vh);
    height: min(90vh, 120vw);
  }

  /* ── Aura rings ── */
  .aura {
    position: absolute;
    inset: -8%;
    border-radius: 50%;
    pointer-events: none;
    transition: all 0.8s ease;
  }
  .aura-outer {
    background: radial-gradient(ellipse at center,
      transparent 50%,
      var(--aura-color) 70%,
      transparent 85%);
    animation: aura-pulse var(--breath-duration) ease-in-out infinite;
  }
  .aura-inner {
    inset: 2%;
    background: radial-gradient(ellipse at center,
      transparent 55%,
      var(--aura-color-strong) 72%,
      transparent 80%);
    animation: aura-pulse var(--breath-duration) ease-in-out infinite;
    animation-delay: calc(var(--breath-duration) * -0.5);
  }

  body.fullbody .aura {
    border-radius: 40% / 50%;
    inset: -6% -15%;
  }

  /* Holographic aura override — cyan shift */
  body.holographic .aura-outer {
    background: radial-gradient(ellipse at center,
      transparent 50%,
      rgba(0, 255, 220, 0.25) 70%,
      transparent 85%);
  }
  body.holographic .aura-inner {
    background: radial-gradient(ellipse at center,
      transparent 55%,
      rgba(0, 255, 220, 0.35) 72%,
      transparent 80%);
  }

  @keyframes aura-pulse {
    0%, 100% { transform: scale(1); opacity: 0.6; }
    50% { transform: scale(1.05); opacity: 1; }
  }

  /* ── Portrait frame ── */
  #portrait-frame {
    position: absolute;
    inset: 5%;
    border-radius: 50%;
    overflow: hidden;
    animation: breathe var(--breath-duration) ease-in-out infinite;
    box-shadow:
      0 0 40px var(--aura-color),
      0 0 80px rgba(147, 51, 234, 0.15),
      inset 0 0 30px rgba(0, 0, 0, 0.4);
    transition: border-radius 0.8s cubic-bezier(0.4, 0, 0.2, 1),
                box-shadow 0.8s ease;
  }

  body.fullbody #portrait-frame {
    border-radius: 20px;
    inset: 3%;
  }

  /* Holographic frame glow */
  body.holographic #portrait-frame {
    box-shadow:
      0 0 40px rgba(0, 255, 220, 0.3),
      0 0 80px rgba(0, 255, 220, 0.1),
      inset 0 0 30px rgba(0, 0, 0, 0.4);
  }

  @keyframes breathe {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.012); }
  }

  /* ── Avatar images (layered for crossfade) ── */
  .avatar-layer {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
    object-position: center top;
    opacity: 0;
    transition: opacity 1.2s cubic-bezier(0.4, 0, 0.2, 1);
    will-change: opacity;
  }
  .avatar-layer.active {
    opacity: 1;
  }

  .avatar-layer.fullbody-layer {
    object-fit: contain;
    object-position: center center;
  }

  /* ══════════════════════════════════════
     HOLOGRAPHIC WIREFRAME OVERLAY
     ══════════════════════════════════════ */

  /* Holographic layer sits on top, fades in during Thinking */
  .holo-layer {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
    object-position: center top;
    opacity: 0;
    pointer-events: none;
    transition: opacity 1.5s cubic-bezier(0.4, 0, 0.2, 1);
    will-change: opacity;
    mix-blend-mode: screen;
    filter: brightness(1.2) saturate(1.3);
  }
  .holo-layer.fullbody-holo {
    object-fit: contain;
    object-position: center center;
  }
  .holo-layer.active {
    opacity: 0.85;
  }

  /* Scanline overlay — only visible in holographic mode */
  #scanlines {
    position: absolute;
    inset: 0;
    background: repeating-linear-gradient(
      to bottom,
      transparent 0px,
      transparent 2px,
      rgba(0, 255, 220, 0.03) 2px,
      rgba(0, 255, 220, 0.03) 4px
    );
    opacity: 0;
    pointer-events: none;
    transition: opacity 1s ease;
    z-index: 2;
  }
  body.holographic #scanlines {
    opacity: 1;
    animation: scanline-drift 8s linear infinite;
  }

  @keyframes scanline-drift {
    0% { background-position: 0 0; }
    100% { background-position: 0 200px; }
  }

  /* Holographic glitch flicker */
  #holo-glitch {
    position: absolute;
    inset: 0;
    opacity: 0;
    pointer-events: none;
    z-index: 3;
    mix-blend-mode: screen;
  }
  body.holographic #holo-glitch {
    animation: holo-flicker 4s ease-in-out infinite;
  }

  @keyframes holo-flicker {
    0%, 92%, 95%, 100% { opacity: 0; }
    93% { opacity: 0.4; background: rgba(0, 255, 220, 0.08); transform: translateX(2px); }
    94% { opacity: 0.2; background: rgba(147, 51, 234, 0.08); transform: translateX(-1px); }
  }

  /* Data stream text during holographic mode */
  #holo-data {
    position: absolute;
    top: 8%;
    right: 6%;
    font-family: 'Courier New', monospace;
    font-size: 0.55rem;
    line-height: 1.4;
    color: rgba(0, 255, 220, 0);
    text-align: right;
    pointer-events: none;
    z-index: 4;
    transition: color 1s ease;
    text-shadow: 0 0 6px rgba(0, 255, 220, 0.5);
    max-width: 35%;
    overflow: hidden;
  }
  body.holographic #holo-data {
    color: rgba(0, 255, 220, 0.45);
  }

  /* ── Eye shimmer overlay ── */
  #eye-shimmer {
    position: absolute;
    inset: 0;
    background: radial-gradient(
      ellipse 30% 8% at 42% 35%,
      rgba(255, 255, 255, 0.12) 0%,
      transparent 100%),
    radial-gradient(
      ellipse 30% 8% at 58% 35%,
      rgba(255, 255, 255, 0.12) 0%,
      transparent 100%);
    opacity: 0;
    animation: eye-glint 6s ease-in-out infinite;
    pointer-events: none;
    transition: background 0.8s ease;
  }

  body.fullbody #eye-shimmer {
    background: radial-gradient(
      ellipse 20% 4% at 45% 18%,
      rgba(255, 255, 255, 0.10) 0%,
      transparent 100%),
    radial-gradient(
      ellipse 20% 4% at 55% 18%,
      rgba(255, 255, 255, 0.10) 0%,
      transparent 100%);
  }

  @keyframes eye-glint {
    0%, 85%, 100% { opacity: 0; }
    90% { opacity: 1; }
    95% { opacity: 0; }
  }

  /* ── Blink overlay ── */
  #blink-overlay {
    position: absolute;
    inset: 0;
    background: linear-gradient(
      to bottom,
      transparent 28%,
      rgba(10, 6, 18, 0.7) 33%,
      rgba(10, 6, 18, 0.7) 37%,
      transparent 42%);
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.08s ease;
  }

  body.fullbody #blink-overlay {
    background: linear-gradient(
      to bottom,
      transparent 14%,
      rgba(10, 6, 18, 0.7) 17%,
      rgba(10, 6, 18, 0.7) 20%,
      transparent 23%);
  }

  /* ── Speaking indicator ── */
  #speak-glow {
    position: absolute;
    inset: 0;
    background: radial-gradient(
      ellipse 25% 12% at 50% 68%,
      var(--gold-glow) 0%,
      transparent 100%);
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s ease;
  }
  body.fullbody #speak-glow {
    background: radial-gradient(
      ellipse 18% 5% at 50% 28%,
      var(--gold-glow) 0%,
      transparent 100%);
  }
  #speak-glow.active {
    animation: speak-pulse 0.6s ease-in-out infinite alternate;
  }

  @keyframes speak-pulse {
    0% { opacity: 0.15; }
    100% { opacity: 0.45; }
  }

  /* ══════════════════════════════════════
     LIP MOVEMENT & FACIAL EXPRESSIONS
     ══════════════════════════════════════ */

  /* Lip sync overlay — simulates mouth opening/closing via masked scale */
  #lip-sync {
    position: absolute;
    inset: 0;
    pointer-events: none;
    z-index: 1;
    opacity: 0;
    transition: opacity 0.2s ease;
  }

  /* Mouth region mask — portrait mode: mouth ~65-72% down the frame */
  #lip-mask {
    position: absolute;
    left: 30%;
    right: 30%;
    top: 62%;
    height: 12%;
    overflow: hidden;
    border-radius: 40%;
  }
  body.fullbody #lip-mask {
    left: 38%;
    right: 38%;
    top: 25%;
    height: 6%;
  }

  /* Inner element clones the avatar image and applies jaw transform */
  #lip-mask-inner {
    position: absolute;
    inset: -2px;
    background: rgba(0, 0, 0, 0.3);
    border-radius: inherit;
    transform-origin: center top;
    animation: none;
  }

  #lip-sync.active #lip-mask-inner {
    animation: lip-open var(--lip-speed, 0.28s) ease-in-out infinite alternate;
  }

  @keyframes lip-open {
    0%   { transform: scaleY(0.2); opacity: 0.1; }
    40%  { transform: scaleY(1.0); opacity: 0.35; }
    70%  { transform: scaleY(0.6); opacity: 0.2; }
    100% { transform: scaleY(0.85); opacity: 0.3; }
  }

  /* Jaw shadow — darkened chin area that shifts down during speech */
  #jaw-shadow {
    position: absolute;
    left: 28%;
    right: 28%;
    top: 68%;
    height: 10%;
    background: radial-gradient(
      ellipse 100% 100% at 50% 0%,
      rgba(0, 0, 0, 0.15) 0%,
      transparent 70%);
    pointer-events: none;
    transform-origin: center top;
    opacity: 0;
    transition: opacity 0.15s ease;
  }
  body.fullbody #jaw-shadow {
    left: 36%;
    right: 36%;
    top: 27%;
    height: 5%;
  }
  #lip-sync.active ~ #jaw-shadow {
    animation: jaw-move var(--lip-speed, 0.28s) ease-in-out infinite alternate;
  }

  @keyframes jaw-move {
    0%   { opacity: 0; transform: translateY(0) scaleY(0.5); }
    50%  { opacity: 0.2; transform: translateY(1.5px) scaleY(1); }
    100% { opacity: 0.1; transform: translateY(0.5px) scaleY(0.7); }
  }

  /* ── Micro-expression transforms ── */
  /* Subtle movement applied to the portrait frame content for each state */
  #portrait-frame {
    --expr-x: 0px;
    --expr-y: 0px;
    --expr-scale: 1;
    --expr-rotate: 0deg;
  }

  #portrait-frame .avatar-layer.active {
    transform: translate(var(--expr-x), var(--expr-y))
               scale(var(--expr-scale))
               rotate(var(--expr-rotate));
    transition: opacity 1.2s cubic-bezier(0.4, 0, 0.2, 1),
                transform 1.5s cubic-bezier(0.4, 0, 0.2, 1);
  }

  /* Idle: perfectly centered, tiny breathing sway */
  body.expr-idle #portrait-frame {
    --expr-x: 0px; --expr-y: 0px; --expr-scale: 1; --expr-rotate: 0deg;
  }

  /* Listening: slight tilt toward speaker, attentive lean */
  body.expr-listening #portrait-frame {
    --expr-x: -1px; --expr-y: -1px; --expr-scale: 1.005; --expr-rotate: -0.4deg;
  }
  body.expr-listening #portrait-frame .avatar-layer.active {
    animation: listen-sway 4s ease-in-out infinite;
  }
  @keyframes listen-sway {
    0%, 100% { transform: translate(-1px, -1px) scale(1.005) rotate(-0.4deg); }
    50%      { transform: translate(1px, 0px) scale(1.005) rotate(0.3deg); }
  }

  /* Thinking: subtle furrow, slight zoom on face */
  body.expr-thinking #portrait-frame {
    --expr-x: 0px; --expr-y: -2px; --expr-scale: 1.015; --expr-rotate: 0deg;
  }
  body.expr-thinking #portrait-frame .avatar-layer.active {
    animation: think-drift 6s ease-in-out infinite;
  }
  @keyframes think-drift {
    0%, 100% { transform: translate(0, -2px) scale(1.015) rotate(0deg); }
    30%      { transform: translate(-1px, -2px) scale(1.018) rotate(-0.2deg); }
    70%      { transform: translate(1px, -1px) scale(1.012) rotate(0.2deg); }
  }

  /* Speaking: animated jaw micro-movement, direct engagement */
  body.expr-speaking #portrait-frame {
    --expr-x: 0px; --expr-y: 0px; --expr-scale: 1.008; --expr-rotate: 0deg;
  }
  body.expr-speaking #portrait-frame .avatar-layer.active {
    animation: speak-micro 0.9s ease-in-out infinite;
  }
  @keyframes speak-micro {
    0%, 100% { transform: translate(0, 0) scale(1.008) rotate(0deg); }
    25%      { transform: translate(0, 0.3px) scale(1.008) rotate(0.1deg); }
    50%      { transform: translate(0, -0.3px) scale(1.01) rotate(0deg); }
    75%      { transform: translate(0, 0.2px) scale(1.008) rotate(-0.1deg); }
  }

  /* Encouraging: warm lean forward, gentle warmth overlay */
  body.expr-encouraging #portrait-frame {
    --expr-x: 0px; --expr-y: -1px; --expr-scale: 1.01; --expr-rotate: 0.3deg;
  }

  /* Warmth glow for encouraging state */
  #warmth-overlay {
    position: absolute;
    inset: 0;
    background: radial-gradient(
      ellipse 70% 50% at 50% 45%,
      rgba(212, 168, 67, 0.06) 0%,
      transparent 70%);
    opacity: 0;
    pointer-events: none;
    transition: opacity 1.2s ease;
    z-index: 1;
  }
  body.expr-encouraging #warmth-overlay {
    opacity: 1;
    animation: warmth-pulse 3s ease-in-out infinite;
  }
  @keyframes warmth-pulse {
    0%, 100% { opacity: 0.6; }
    50% { opacity: 1; }
  }

  /* ── Brow region overlay — furrow during thinking ── */
  #brow-overlay {
    position: absolute;
    left: 25%;
    right: 25%;
    top: 28%;
    height: 8%;
    pointer-events: none;
    z-index: 1;
    opacity: 0;
    transition: opacity 0.8s ease;
  }
  body.fullbody #brow-overlay {
    left: 35%;
    right: 35%;
    top: 14%;
    height: 4%;
  }
  body.expr-thinking #brow-overlay {
    opacity: 1;
    background: linear-gradient(
      to bottom,
      transparent 0%,
      rgba(30, 10, 50, 0.12) 40%,
      rgba(30, 10, 50, 0.12) 60%,
      transparent 100%);
    animation: brow-furrow 5s ease-in-out infinite;
  }
  @keyframes brow-furrow {
    0%, 100% { transform: scaleY(1); opacity: 0.7; }
    50%      { transform: scaleY(1.3); opacity: 1; }
  }

  /* ── Gold ring border ── */
  #gold-ring {
    position: absolute;
    inset: 4.5%;
    border-radius: 50%;
    border: 2px solid var(--gold);
    opacity: 0.4;
    pointer-events: none;
    box-shadow: 0 0 15px var(--gold-glow), inset 0 0 15px var(--gold-glow);
    animation: ring-breathe var(--breath-duration) ease-in-out infinite;
    transition: all 0.8s cubic-bezier(0.4, 0, 0.2, 1);
  }

  body.fullbody #gold-ring {
    border-radius: 18px;
    inset: 2.5%;
  }

  /* Holographic ring shifts to cyan */
  body.holographic #gold-ring {
    border-color: rgba(0, 255, 220, 0.5);
    box-shadow: 0 0 15px rgba(0, 255, 220, 0.3), inset 0 0 15px rgba(0, 255, 220, 0.15);
  }

  @keyframes ring-breathe {
    0%, 100% { opacity: 0.3; }
    50% { opacity: 0.6; }
  }

  /* ── Full-body ground glow ── */
  #ground-glow {
    display: none;
    position: absolute;
    bottom: -5%;
    left: -10%;
    right: -10%;
    height: 25%;
    background: radial-gradient(
      ellipse 60% 100% at 50% 100%,
      var(--aura-color-strong) 0%,
      var(--aura-color) 40%,
      transparent 80%);
    pointer-events: none;
    animation: ground-pulse var(--breath-duration) ease-in-out infinite;
    filter: blur(8px);
    transition: background 0.8s ease;
  }
  body.fullbody #ground-glow { display: block; }

  body.holographic #ground-glow {
    background: radial-gradient(
      ellipse 60% 100% at 50% 100%,
      rgba(0, 255, 220, 0.35) 0%,
      rgba(0, 255, 220, 0.15) 40%,
      transparent 80%);
  }

  @keyframes ground-pulse {
    0%, 100% { opacity: 0.4; transform: scaleX(1); }
    50% { opacity: 0.7; transform: scaleX(1.05); }
  }

  /* ── Turnaround angle indicator ── */
  #angle-indicator {
    display: none;
    position: fixed;
    bottom: 80px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 10;
    pointer-events: none;
  }
  body.fullbody #angle-indicator { display: flex; }

  .angle-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    margin: 0 6px;
    background: rgba(147, 51, 234, 0.25);
    border: 1px solid rgba(147, 51, 234, 0.3);
    transition: all 0.4s ease;
  }
  .angle-dot.active {
    background: var(--gold);
    border-color: var(--gold);
    box-shadow: 0 0 8px var(--gold-glow);
    transform: scale(1.3);
  }

  .angle-label {
    position: absolute;
    top: -20px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 0.6rem;
    letter-spacing: 0.15em;
    color: rgba(192, 160, 255, 0.5);
    white-space: nowrap;
    opacity: 0;
    transition: opacity 0.4s ease;
  }
  body.fullbody .angle-label { opacity: 1; }

  /* ── Mode toggle button ── */
  #mode-toggle {
    position: fixed;
    top: 16px;
    left: 16px;
    z-index: 10;
    background: rgba(147, 51, 234, 0.15);
    border: 1px solid rgba(147, 51, 234, 0.3);
    border-radius: 6px;
    color: rgba(192, 160, 255, 0.7);
    font-size: 0.7rem;
    letter-spacing: 0.1em;
    padding: 6px 12px;
    cursor: pointer;
    transition: all 0.3s ease;
    font-family: inherit;
    text-transform: uppercase;
  }
  #mode-toggle:hover {
    background: rgba(147, 51, 234, 0.3);
    color: var(--gold);
    border-color: var(--gold);
  }

  /* Holo indicator badge */
  #holo-badge {
    position: fixed;
    top: 44px;
    left: 16px;
    z-index: 10;
    font-size: 0.55rem;
    letter-spacing: 0.2em;
    color: rgba(0, 255, 220, 0);
    text-transform: uppercase;
    pointer-events: none;
    transition: color 0.8s ease;
  }
  body.holographic #holo-badge {
    color: rgba(0, 255, 220, 0.6);
    animation: holo-badge-pulse 2s ease-in-out infinite;
  }

  @keyframes holo-badge-pulse {
    0%, 100% { opacity: 0.4; }
    50% { opacity: 1; }
  }

  /* ── Status HUD ── */
  #hud {
    position: fixed;
    bottom: 24px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 10;
    text-align: center;
    pointer-events: none;
  }

  #persona-name {
    font-size: 1.3rem;
    font-weight: 300;
    letter-spacing: 0.3em;
    text-transform: uppercase;
    color: var(--gold);
    text-shadow: 0 0 20px var(--gold-glow);
    margin-bottom: 6px;
    transition: color 0.8s ease, text-shadow 0.8s ease;
  }

  body.holographic #persona-name {
    color: var(--holo-cyan);
    text-shadow: 0 0 20px rgba(0, 255, 220, 0.5);
  }

  #status-text {
    font-size: 0.8rem;
    letter-spacing: 0.15em;
    color: rgba(192, 160, 255, 0.7);
    transition: all 0.6s ease;
  }

  #mood-bar {
    margin-top: 8px;
    height: 2px;
    width: 200px;
    background: rgba(147, 51, 234, 0.2);
    border-radius: 1px;
    overflow: hidden;
    margin-left: auto;
    margin-right: auto;
  }

  #mood-fill {
    height: 100%;
    width: 50%;
    background: linear-gradient(90deg, var(--violet), var(--gold));
    border-radius: 1px;
    transition: width 1.5s ease, background 1.5s ease;
  }

  body.holographic #mood-fill {
    background: linear-gradient(90deg, var(--violet), var(--holo-cyan));
  }

  /* ── Connection indicator ── */
  #connection {
    position: fixed;
    top: 16px;
    right: 16px;
    z-index: 10;
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 0.7rem;
    color: rgba(192, 160, 255, 0.5);
    letter-spacing: 0.1em;
  }

  #conn-dot {
    width: 6px;
    height: 6px;
    border-radius: 50%;
    background: #555;
    transition: background 0.5s ease;
  }
  #conn-dot.connected { background: #4ade80; box-shadow: 0 0 8px rgba(74, 222, 128, 0.5); }
  #conn-dot.reconnecting { background: #facc15; animation: blink-dot 1s infinite; }

  @keyframes blink-dot {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.3; }
  }

  /* ── Floating particles ── */
  .particle {
    position: fixed;
    color: var(--gold);
    opacity: 0;
    pointer-events: none;
    font-size: 14px;
    animation: float-up linear infinite;
    will-change: transform, opacity;
  }

  @keyframes float-up {
    0%   { transform: translateY(0) rotate(0deg) scale(0.5); opacity: 0; }
    15%  { opacity: 0.6; }
    85%  { opacity: 0.3; }
    100% { transform: translateY(-100vh) rotate(360deg) scale(0.2); opacity: 0; }
  }
</style>
</head>
<body>

<canvas id="cosmos"></canvas>

<div id="avatar-stage">
  <div class="aura aura-outer"></div>
  <div class="aura aura-inner"></div>

  <div id="portrait-frame">
    <!-- Portrait mode layers (bust) -->
    <img class="avatar-layer portrait-layer active" id="layer-idle"        src="idle.png"        alt="" draggable="false">
    <img class="avatar-layer portrait-layer"        id="layer-listening"   src="listening.png"   alt="" draggable="false">
    <img class="avatar-layer portrait-layer"        id="layer-thinking"    src="thinking.png"    alt="" draggable="false">
    <img class="avatar-layer portrait-layer"        id="layer-speaking"    src="speaking.png"    alt="" draggable="false">
    <img class="avatar-layer portrait-layer"        id="layer-encouraging" src="encouraging.png" alt="" draggable="false">

    <!-- Full-body mode layers (turnaround angles) -->
    <img class="avatar-layer fullbody-layer" id="layer-fb-front"        src="fullbody_front.png"        alt="" draggable="false">
    <img class="avatar-layer fullbody-layer" id="layer-fb-threequarter" src="fullbody_threequarter.png" alt="" draggable="false">
    <img class="avatar-layer fullbody-layer" id="layer-fb-side"         src="fullbody_side.png"         alt="" draggable="false">
    <img class="avatar-layer fullbody-layer" id="layer-fb-back"         src="fullbody_back.png"         alt="" draggable="false">
    <img class="avatar-layer fullbody-layer" id="layer-fb-sideleft"     src="fullbody_sideleft.png"     alt="" draggable="false">

    <!-- Holographic wireframe layers (overlay during Thinking) -->
    <img class="holo-layer portrait-holo" id="holo-portrait"    src="holo_portrait.png"    alt="" draggable="false">
    <img class="holo-layer fullbody-holo" id="holo-fb-front"    src="holo_front.png"       alt="" draggable="false">
    <img class="holo-layer fullbody-holo" id="holo-fb-34"       src="holo_threequarter.png" alt="" draggable="false">
    <img class="holo-layer fullbody-holo" id="holo-fb-side"     src="holo_side.png"        alt="" draggable="false">
    <img class="holo-layer fullbody-holo" id="holo-fb-back"     src="holo_back.png"        alt="" draggable="false">
    <img class="holo-layer fullbody-holo" id="holo-fb-sideleft" src="holo_sideleft.png"    alt="" draggable="false">

    <div id="scanlines"></div>
    <div id="holo-glitch"></div>
    <div id="holo-data"></div>

    <div id="eye-shimmer"></div>
    <div id="blink-overlay"></div>
    <div id="speak-glow"></div>
    <div id="lip-sync"><div id="lip-mask"><div id="lip-mask-inner"></div></div></div>
    <div id="jaw-shadow"></div>
    <div id="brow-overlay"></div>
    <div id="warmth-overlay"></div>

    <!-- Live AI-generated video frame canvas (overlays static portrait when stream active) -->
    <canvas id="avatarCanvas" style="position:absolute;top:0;left:0;width:100%;height:100%;display:none;border-radius:inherit;object-fit:cover;z-index:50;"></canvas>
  </div>

  <div id="gold-ring"></div>
  <div id="ground-glow"></div>
</div>

<!-- Turnaround angle dots -->
<div id="angle-indicator">
  <span class="angle-label" id="angle-name">front</span>
  <div class="angle-dot active" data-angle="0"></div>
  <div class="angle-dot" data-angle="1"></div>
  <div class="angle-dot" data-angle="2"></div>
  <div class="angle-dot" data-angle="3"></div>
  <div class="angle-dot" data-angle="4"></div>
</div>

<button id="mode-toggle">Portrait</button>
<div id="holo-badge">HOLOGRAPHIC</div>

<div id="hud">
  <div id="persona-name">Iaret</div>
  <div id="status-text">Awakening...</div>
  <div id="mood-bar"><div id="mood-fill"></div></div>
</div>

<div id="connection">
  <span id="conn-dot"></span>
  <span id="conn-label">DISCONNECTED</span>
</div>

<div id="particles"></div>

<script>
// ═══════════════════════════════════════════════
//  Cosmic background — star field on canvas
// ═══════════════════════════════════════════════
const cosmos = document.getElementById('cosmos');
const ctx = cosmos.getContext('2d');
let stars = [];

function resizeCosmos() {
  cosmos.width = window.innerWidth;
  cosmos.height = window.innerHeight;
  initStars();
}

function initStars() {
  stars = [];
  const count = Math.floor((cosmos.width * cosmos.height) / 3000);
  for (let i = 0; i < count; i++) {
    stars.push({
      x: Math.random() * cosmos.width,
      y: Math.random() * cosmos.height,
      r: Math.random() * 1.5 + 0.3,
      a: Math.random(),
      speed: Math.random() * 0.0008 + 0.0002,
      phase: Math.random() * Math.PI * 2,
    });
  }
}

function drawCosmos(t) {
  ctx.clearRect(0, 0, cosmos.width, cosmos.height);

  const grd = ctx.createRadialGradient(
    cosmos.width * 0.5, cosmos.height * 0.45, 0,
    cosmos.width * 0.5, cosmos.height * 0.45, cosmos.width * 0.7
  );
  grd.addColorStop(0, 'rgba(88, 28, 135, 0.08)');
  grd.addColorStop(0.5, 'rgba(59, 7, 100, 0.04)');
  grd.addColorStop(1, 'transparent');
  ctx.fillStyle = grd;
  ctx.fillRect(0, 0, cosmos.width, cosmos.height);

  for (const s of stars) {
    const twinkle = 0.4 + 0.6 * Math.sin(t * s.speed * 1000 + s.phase);
    ctx.beginPath();
    ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(210, 190, 255, ${s.a * twinkle})`;
    ctx.fill();
  }

  requestAnimationFrame(drawCosmos);
}

window.addEventListener('resize', resizeCosmos);
resizeCosmos();
requestAnimationFrame(drawCosmos);


// ═══════════════════════════════════════════════
//  Floating particles
// ═══════════════════════════════════════════════
const particlesEl = document.getElementById('particles');
const SYMBOLS = ['☥', '✦', '◆', '✧', '⟐', '◇'];

function spawnParticle() {
  const el = document.createElement('div');
  el.className = 'particle';
  el.textContent = SYMBOLS[Math.floor(Math.random() * SYMBOLS.length)];
  el.style.left = (Math.random() * 100) + 'vw';
  el.style.fontSize = (10 + Math.random() * 12) + 'px';
  el.style.animationDuration = (8 + Math.random() * 12) + 's';
  el.style.animationDelay = '0s';
  el.style.color = Math.random() > 0.5
    ? 'rgba(212, 168, 67, 0.4)'
    : 'rgba(192, 160, 255, 0.3)';
  particlesEl.appendChild(el);
  setTimeout(() => el.remove(), 20000);
}

setInterval(spawnParticle, 1200);
for (let i = 0; i < 8; i++) setTimeout(spawnParticle, i * 300);


// ═══════════════════════════════════════════════
//  Blink simulation
// ═══════════════════════════════════════════════
const blinkEl = document.getElementById('blink-overlay');

function scheduleBlink() {
  const delay = 3000 + Math.random() * 5000;
  setTimeout(() => {
    if (isFullbody && currentAngle > 1) { scheduleBlink(); return; }
    blinkEl.style.opacity = '1';
    setTimeout(() => { blinkEl.style.opacity = '0'; }, 120);
    if (Math.random() < 0.2) {
      setTimeout(() => {
        blinkEl.style.opacity = '1';
        setTimeout(() => { blinkEl.style.opacity = '0'; }, 100);
      }, 250);
    }
    scheduleBlink();
  }, delay);
}
scheduleBlink();


// ═══════════════════════════════════════════════
//  View mode management
// ═══════════════════════════════════════════════
let isFullbody = false;
const modeToggle = document.getElementById('mode-toggle');
const portraitLayers = document.querySelectorAll('.portrait-layer');
const fullbodyLayers = document.querySelectorAll('.fullbody-layer');
const portraitHolos = document.querySelectorAll('.portrait-holo');
const fullbodyHolos = document.querySelectorAll('.fullbody-holo');
const angleName = document.getElementById('angle-name');

const ANGLES = ['front', '¾ right', 'profile right', 'back', 'profile left'];

function setViewMode(fullbody) {
  isFullbody = fullbody;
  document.body.classList.toggle('fullbody', fullbody);
  modeToggle.textContent = fullbody ? 'Full Body' : 'Portrait';

  portraitLayers.forEach(el => { el.style.display = fullbody ? 'none' : ''; });
  fullbodyLayers.forEach(el => { el.style.display = fullbody ? '' : 'none'; });
  portraitHolos.forEach(el => { el.style.display = fullbody ? 'none' : ''; });
  fullbodyHolos.forEach(el => { el.style.display = fullbody ? '' : 'none'; });

  if (fullbody) {
    setAngle(currentAngle);
  } else {
    setAvatarState(currentState);
  }
  // Re-apply holographic if active
  updateHolographic();
}

// Initialize: hide fullbody layers and all holo layers
fullbodyLayers.forEach(el => { el.style.display = 'none'; });
fullbodyHolos.forEach(el => { el.style.display = 'none'; });

modeToggle.addEventListener('click', () => setViewMode(!isFullbody));


// ═══════════════════════════════════════════════
//  Turnaround angle management (fullbody mode)
// ═══════════════════════════════════════════════
let currentAngle = 0;
const fbLayers = {
  0: document.getElementById('layer-fb-front'),
  1: document.getElementById('layer-fb-threequarter'),
  2: document.getElementById('layer-fb-side'),
  3: document.getElementById('layer-fb-back'),
  4: document.getElementById('layer-fb-sideleft'),
};
const holoFbLayers = {
  0: document.getElementById('holo-fb-front'),
  1: document.getElementById('holo-fb-34'),
  2: document.getElementById('holo-fb-side'),
  3: document.getElementById('holo-fb-back'),
  4: document.getElementById('holo-fb-sideleft'),
};
const angleDots = document.querySelectorAll('.angle-dot');

function setAngle(angle) {
  if (angle < 0 || angle > 4) angle = 0;
  currentAngle = angle;

  for (const [key, el] of Object.entries(fbLayers)) {
    el.classList.toggle('active', parseInt(key) === angle);
  }

  // Update holo layers to match current angle
  updateHolographic();

  angleDots.forEach((dot, i) => dot.classList.toggle('active', i === angle));
  angleName.textContent = ANGLES[angle] || 'front';

  const showFace = angle <= 1;
  document.getElementById('eye-shimmer').style.display = showFace ? '' : 'none';
  blinkEl.style.display = showFace ? '' : 'none';
  document.getElementById('speak-glow').style.display = showFace ? '' : 'none';
}

let turnaroundTimer = null;
let turnaroundPaused = false;

function startTurnaround() {
  stopTurnaround();
  turnaroundTimer = setInterval(() => {
    if (turnaroundPaused || !isFullbody) return;
    setAngle((currentAngle + 1) % 5);
  }, 4000);
}

function stopTurnaround() {
  if (turnaroundTimer) { clearInterval(turnaroundTimer); turnaroundTimer = null; }
}

function updateTurnaroundForState(state) {
  if (!isFullbody) return;
  if (state === 'Idle') {
    turnaroundPaused = false;
    if (!turnaroundTimer) startTurnaround();
  } else {
    turnaroundPaused = true;
    setAngle(state === 'Listening' ? 1 : 0);
  }
}


// ═══════════════════════════════════════════════
//  Holographic wireframe system
// ═══════════════════════════════════════════════
let holoActive = false;
const holoData = document.getElementById('holo-data');
const holoPortrait = document.getElementById('holo-portrait');

const HOLO_PHRASES = [
  'ANALYZING PATTERN...',
  'CONSCIOUSNESS DEPTH: ∞',
  'SYMBOLIC REASONING',
  'MERKLE STATE: VALID',
  'METTA EVALUATION',
  'NEURAL TOPOLOGY OK',
  'RECURSIVE THOUGHT',
  'ATTENTION LAYER 7',
  'SEMANTIC BINDING',
  'EIGENVALUE STABLE',
  'OUROBOROS CYCLE',
  'SELF-REFERENCE ☥',
];

let holoTextTimer = null;

function setHolographic(active) {
  holoActive = active;
  document.body.classList.toggle('holographic', active);
  updateHolographic();

  if (active) {
    // Start data stream
    cycleHoloText();
  } else {
    if (holoTextTimer) clearTimeout(holoTextTimer);
    holoData.textContent = '';
  }
}

function updateHolographic() {
  // Deactivate all holo layers first
  document.querySelectorAll('.holo-layer').forEach(el => el.classList.remove('active'));

  if (!holoActive) return;

  if (isFullbody) {
    // Show holo for current angle
    const layer = holoFbLayers[currentAngle];
    if (layer) layer.classList.add('active');
  } else {
    // Show portrait holo
    holoPortrait.classList.add('active');
  }
}

function cycleHoloText() {
  if (!holoActive) return;
  const lines = [];
  for (let i = 0; i < 5; i++) {
    lines.push(HOLO_PHRASES[Math.floor(Math.random() * HOLO_PHRASES.length)]);
  }
  holoData.textContent = lines.join('\n');
  holoTextTimer = setTimeout(cycleHoloText, 2000 + Math.random() * 1500);
}


// ═══════════════════════════════════════════════
//  Avatar state management
// ═══════════════════════════════════════════════
const layers = {
  Idle:        document.getElementById('layer-idle'),
  Listening:   document.getElementById('layer-listening'),
  Thinking:    document.getElementById('layer-thinking'),
  Speaking:    document.getElementById('layer-speaking'),
  Encouraging: document.getElementById('layer-encouraging'),
};

const speakGlow = document.getElementById('speak-glow');
const lipSync = document.getElementById('lip-sync');
const statusText = document.getElementById('status-text');
const personaNameEl = document.getElementById('persona-name');
const moodFill = document.getElementById('mood-fill');
const connDot = document.getElementById('conn-dot');
const connLabel = document.getElementById('conn-label');

let currentState = 'Idle';

const STATE_STATUS = {
  Idle:        'Watchful stillness',
  Listening:   'Listening...',
  Thinking:    'Contemplating...',
  Speaking:    'Speaking',
  Encouraging: 'With warmth',
};

const EXPR_CLASSES = ['expr-idle', 'expr-listening', 'expr-thinking', 'expr-speaking', 'expr-encouraging'];

// ── Lip-sync speed variation — randomizes cadence for natural feel ──
let lipSpeedTimer = null;

function startLipSync() {
  lipSync.classList.add('active');
  varyLipSpeed();
}

function stopLipSync() {
  lipSync.classList.remove('active');
  if (lipSpeedTimer) { clearTimeout(lipSpeedTimer); lipSpeedTimer = null; }
}

function varyLipSpeed() {
  if (!lipSync.classList.contains('active')) return;
  // Random cadence between 0.18s (fast syllable) and 0.42s (slow pause)
  const speed = (0.18 + Math.random() * 0.24).toFixed(2) + 's';
  document.documentElement.style.setProperty('--lip-speed', speed);
  lipSpeedTimer = setTimeout(varyLipSpeed, 200 + Math.random() * 400);
}

function setAvatarState(state) {
  if (!layers[state]) state = 'Idle';
  const changed = state !== currentState;

  if (!isFullbody && changed) {
    for (const [key, el] of Object.entries(layers)) {
      el.classList.toggle('active', key === state);
    }
  }

  // Speaking effects: golden glow + lip movement
  speakGlow.classList.toggle('active', state === 'Speaking');
  if (state === 'Speaking') {
    startLipSync();
  } else {
    stopLipSync();
  }

  // Micro-expression body classes
  EXPR_CLASSES.forEach(c => document.body.classList.remove(c));
  document.body.classList.add('expr-' + state.toLowerCase());

  const root = document.documentElement;
  switch (state) {
    case 'Listening': root.style.setProperty('--breath-duration', '3.5s'); break;
    case 'Thinking':  root.style.setProperty('--breath-duration', '5.5s'); break;
    case 'Speaking':  root.style.setProperty('--breath-duration', '2.8s'); break;
    default:          root.style.setProperty('--breath-duration', '4.5s'); break;
  }

  currentState = state;

  // Holographic mode activates during Thinking
  setHolographic(state === 'Thinking');

  updateTurnaroundForState(state);
}

function applySnapshot(snap) {
  const stateNames = ['Idle', 'Listening', 'Thinking', 'Speaking', 'Encouraging'];
  const visualName = typeof snap.VisualState === 'number'
    ? (stateNames[snap.VisualState] || 'Idle')
    : snap.VisualState;

  setAvatarState(visualName);

  if (snap.PersonaName) personaNameEl.textContent = snap.PersonaName;
  statusText.textContent = snap.StatusText
    ? `${snap.Mood || ''} — ${snap.StatusText}`.replace(/^ — /, '')
    : (snap.Mood || STATE_STATUS[visualName] || '');

  const positivity = Math.max(0, Math.min(1, snap.Positivity || 0.5));
  moodFill.style.width = (positivity * 100) + '%';

  const energy = Math.max(0, Math.min(1, snap.Energy || 0.5));
  const auraAlpha = 0.2 + energy * 0.5;
  document.documentElement.style.setProperty(
    '--aura-color', `rgba(147, 51, 234, ${auraAlpha})`);
  document.documentElement.style.setProperty(
    '--aura-color-strong', `rgba(147, 51, 234, ${auraAlpha + 0.15})`);
}


// ═══════════════════════════════════════════════
//  WebSocket connection
// ═══════════════════════════════════════════════
const WS_PORT = window.location.port || '9471';
let ws = null;
let reconnectDelay = 1000;

function connectWs() {
  connDot.className = 'reconnecting';
  connLabel.textContent = 'CONNECTING';

  ws = new WebSocket(`ws://localhost:${WS_PORT}/avatar`);
  ws.binaryType = 'arraybuffer'; // Must be set before messages arrive

  ws.onopen = () => {
    reconnectDelay = 1000;
    connDot.className = 'connected';
    connLabel.textContent = 'LINKED';
    statusText.textContent = 'Connected to Ouroboros';
  };

  // Video frame canvas setup
  const avatarCanvas = document.getElementById('avatarCanvas');
  const ctx = avatarCanvas ? avatarCanvas.getContext('2d') : null;
  let lastFrameTime = 0;
  const FRAME_TIMEOUT_MS = 5000; // Hide canvas if no frames for 5s

  // Check for frame timeout and hide canvas
  if (avatarCanvas) {
    setInterval(() => {
      if (lastFrameTime > 0 && Date.now() - lastFrameTime > FRAME_TIMEOUT_MS) {
        avatarCanvas.style.display = 'none';
        lastFrameTime = 0;
      }
    }, 1000);
  }

  ws.onmessage = (ev) => {
    if (ev.data instanceof ArrayBuffer) {
      // Binary message = video frame
      const data = new Uint8Array(ev.data);
      if (data.length > 1 && data[0] === 0x01 && avatarCanvas && ctx) {
        const frameBytes = data.slice(1);
        const blob = new Blob([frameBytes], { type: 'image/jpeg' });
        const url = URL.createObjectURL(blob);
        avatarCanvas.style.display = 'block';
        // Size canvas to match portrait frame
        const frame = document.getElementById('portrait-frame');
        if (frame) {
          avatarCanvas.width = frame.offsetWidth;
          avatarCanvas.height = frame.offsetHeight;
        }
        const img = new Image();
        img.onload = () => {
          ctx.drawImage(img, 0, 0, avatarCanvas.width, avatarCanvas.height);
          URL.revokeObjectURL(url);
        };
        img.src = url;
        lastFrameTime = Date.now();
      }
    } else {
      // JSON state snapshot (existing path)
      try {
        const snap = JSON.parse(ev.data);
        applySnapshot(snap);
      } catch (e) {
        console.warn('Invalid avatar state:', e);
      }
    }
  };

  ws.onclose = () => {
    connDot.className = '';
    connLabel.textContent = 'DISCONNECTED';
    statusText.textContent = 'Awaiting reconnection...';
    setTimeout(connectWs, reconnectDelay);
    reconnectDelay = Math.min(reconnectDelay * 1.5, 8000);
  };

  ws.onerror = () => ws.close();
}

connectWs();


// ═══════════════════════════════════════════════
//  Idle ambient cycling
// ═══════════════════════════════════════════════
let lastUpdateTime = Date.now();

setInterval(() => {
  if (Date.now() - lastUpdateTime > 30000 && currentState === 'Idle') {
    if (Math.random() < 0.3) {
      if (!isFullbody) {
        setAvatarState('Encouraging');
        setTimeout(() => setAvatarState('Idle'), 2500);
      }
    }
  }
}, 15000);

const origApply = applySnapshot;
applySnapshot = function(snap) {
  lastUpdateTime = Date.now();
  origApply(snap);
};


// ═══════════════════════════════════════════════
//  Keyboard shortcuts
// ═══════════════════════════════════════════════
document.addEventListener('keydown', (e) => {
  switch(e.key) {
    case '1': setAvatarState('Idle'); break;
    case '2': setAvatarState('Listening'); break;
    case '3': setAvatarState('Thinking'); break;
    case '4': setAvatarState('Speaking'); break;
    case '5': setAvatarState('Encouraging'); break;

    case 'q': if (isFullbody) { turnaroundPaused = true; setAngle(0); } break;
    case 'w': if (isFullbody) { turnaroundPaused = true; setAngle(1); } break;
    case 'e': if (isFullbody) { turnaroundPaused = true; setAngle(2); } break;
    case 'r': if (isFullbody) { turnaroundPaused = true; setAngle(3); } break;
    case 't': if (isFullbody) { turnaroundPaused = true; setAngle(4); } break;

    case 'ArrowLeft':
      if (isFullbody) { turnaroundPaused = true; setAngle((currentAngle + 4) % 5); }
      break;
    case 'ArrowRight':
      if (isFullbody) { turnaroundPaused = true; setAngle((currentAngle + 1) % 5); }
      break;

    case 'f': setViewMode(!isFullbody); break;
    case 'h': setHolographic(!holoActive); break;
    case ' ': if (isFullbody) { turnaroundPaused = false; startTurnaround(); } break;
  }
});
</script>
</body>
</html>
